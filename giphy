#!/usr/bin/env python3

# Giphizer 2.0
# Copyright (c) 2016, 2024 Jason Jackson
# Released under the MIT license; see LICENSE for details.
# https://github.com/jakshin/giphizer

"""
Have you ever though 'oh man, Giphy is great, but I wish I could use it in my terminal'?
Well now you can! (If you use iTerm or WezTerm, but not tmux or GNU screen, that is...)
For usage info, just run this without arguments, or with -h or --help.
"""

import argparse
import errno
import fcntl
import json
import os
import platform
import re
import shutil
import socket
import ssl
import sys
import tempfile
import urllib.error
import urllib.parse
import urllib.request
from base64 import b64encode
from os import path
from urllib.parse import urlencode


def main():
    """
    Main program logic.
    """
    try:
        args = parse_command_line()
        if args is None:
            return 0

        incapable = check_image_capability(args)
        if incapable is not None:
            fail(incapable)

        image_info = choose_image(args)
        image_url = image_info["image_url"]
        image_id = image_info["id"]

        image_data = load_cached_image(image_id)
        if image_data is None:
            image_data = download_image(image_url)
            if args.max_cache > 0:
                cache_image(image_id, image_data)

        image_b64 = b64encode(image_data).decode("utf-8")
        display_image(image_b64, len(image_data), None, image_url)

        if args.show_url:
            print(image_info["page_url"])
        display_logo(False)

        clean_cache(args)
        return 0

    except GiphizerException as ex:
        err_msg = str(ex)
        if err_msg:
            sys.stderr.write("Error: %s\n" % str(ex))
        return 1


class GiphizerException(Exception):
    """Represents failure and a need to exit immediately."""
    pass


def fail(err_msg):
    """
    Raises a GiphizerException with the given error message, which gets written to stderr,
    and causes the script to exit with an error code.
    """
    raise GiphizerException(err_msg)


# ----- Parsing options from our config file and command line -----

def parse_command_line():
    """
    Parses command-line options, returning a Namespace. Displays usage/error and exits
    if there are any problems with the command line, or if the user requested help.
    """
    parser = NoExitArgParser(usage="%(prog)s [options] topic",
                             description="Displays a Giphy GIF in your terminal, if it's capable of that. "
                                         "Works on iTerm and WezTerm, but not in tmux or GNU screen.",
                             add_help=False)
    parser.add_argument("topic", nargs="*",
                        help="The word, phrase or ID that determines which GIF to show")
    parser.add_argument("-h", "--help", action="store_true",
                        help="Show this help message and exit")

    parser.add_argument("--mode", default="best", choices=["best", "random", "id"],
                        help="How Giphy will choose a GIF: the best topical match it can find, "
                        "using its special sauce algorithm; a random topical match; "
                        "or a specific image selected by ID (default = 'best')")
    parser.add_argument("--max-rating", choices=["y", "g", "pg", "pg-13", "r"],
                        help="Maximum maturity rating (default = no limit, i.e. use any GIF)")
    parser.add_argument("--max-size", choices=["2MB", "5MB", "8MB", "none"],
                        help="Maximum image size in megabytes (default = no limit)")

    parser.add_argument("--max-cache", type=int, metavar="num", default=100,
                        help="Maximum number of GIFs to retain in a local disk cache "
                        "(default = 100, use 0 to disable caching and clear any existing cache)")
    parser.add_argument("-f", "--force", action="store_true",
                        help="Attempt to display a GIF, even if it may not be supported in this terminal")
    parser.add_argument("-s", "--show-url", action="store_true",
                        help="Show the GIF's URL just below it in the terminal")

    # Try to get options from our dotfile, then from the command line
    context = ""

    try:
        dotfile_argv, dotfile = read_options_from_dotfile()
        context = " in %s" % dotfile
        args = parser.parse_args(dotfile_argv)

        args.topic = []  # Ignore some stuff in the dotfile
        args.help = False

        context = ""
        parser.parse_args(namespace=args)
    except argparse.ArgumentError as ex:
        sys.stderr.write("Error%s: %s\n" % (context, str(ex)))
        sys.stderr.write("For usage information, run: giphy --help\n")
        raise GiphizerException

    if args.max_cache < 0:
        args.max_cache = 0

    # Massage the topic/ID received into a single trimmed string
    topic = []
    for arg in args.topic:
        arg = re.sub(r'\s+', " ", arg).strip()
        if arg != "":
            topic.append(arg)
    args.topic = " ".join(topic)

    # Display help/usage info and exit, if needed
    if args.topic == "" or args.help:
        columns = int(shutil.get_terminal_size().columns)
        if columns > 100:
            os.environ["COLUMNS"] = "100"

        parser.print_help()
        print("\nSource: https://github.com/jakshin/giphizer\n")
        print("All images displayed are from Giphy (https://giphy.com),\n"
              "but this program has no official connection with Giphy.")

        if check_image_capability(args) is None:
            print()
            display_logo(True)

        return None
    else:
        return args


class NoExitArgParser(argparse.ArgumentParser):
    """
    Just like argparse.ArgumentParser, but throws ArgumentError instead of exiting.
    Because exit_on_error is only in Python 3.9+, and doesn't work perfectly anyway:
    https://github.com/python/cpython/issues/103498.
    """
    def exit(self, status=0, message=None):
        if status:
            raise argparse.ArgumentError(None, message)

    def error(self, message):
        raise argparse.ArgumentError(None, message)


def read_options_from_dotfile():
    """
    Reads options from the first of our dotfiles that exists, returning an array of strings,
    and the dotfile's "pretty path" (where $HOME is represented by "~" instead of its actual path).
    Lines beginning with hash characters are ignored, so they can serve as comments in the file.
    """
    dotfiles = ["~/.giphyrc"]
    config_home = os.environ.get("XDG_CONFIG_HOME")
    if config_home is not None and config_home.startswith("/"):
        home = os.environ.get("HOME")
        if home is not None and home != "":
            if not home.endswith("/"):
                home += "/"
            if config_home.startswith(home):
                config_home = config_home.replace(home, "~/")
        dotfiles.append("%s/giphy/giphyrc" % config_home)
    else:
        dotfiles.append("~/.config/giphy/giphyrc")

    for dotfile in dotfiles:
        dotfile_path = path.expanduser(dotfile)
        if not path.isfile(dotfile_path):
            continue  # Because what if it's actually a symlink to /dev/zero? :)

        try:
            with open(dotfile_path, "r") as option_file:
                lines = option_file.readlines()

            all_args = []
            for line in lines:
                line = line.strip()
                if line != "" and line[0] != "#":
                    args = line.split()
                    all_args.extend(args)

            # Only read one dotfile
            return all_args, dotfile
        except (FileNotFoundError, IsADirectoryError, PermissionError):
            pass

    # Couldn't find our dotfile anywhere
    return [], None


# ----- Using Giphy's API, downloading images -----

def choose_image(args):
    """
    Chooses a GIF, using the appropriate URL for the current mode.
    Returns a dictionary containing some info about the GIF, including its URL.
    """
    api_key = os.environ.get("GIPHY_API_KEY")
    if api_key is None:
        fail("No API key provided in the $GIPHY_API_KEY environment variable")

    url = "https://api.giphy.com/v1/gifs/"

    if args.mode == "id":
        url += urllib.parse.quote(args.topic)
        url += "?%s" % urlencode({"api_key": api_key})
    elif args.mode == "random":
        url += "random?%s" % urlencode({"api_key": api_key, "tag": args.topic})
    else:
        # Use the 'translate' endpoint by default, for "best" mode
        url += "translate?%s" % urlencode({"api_key": api_key, "s": args.topic})

    if args.max_rating is not None:
        url += "&rating=" + args.max_rating

    try:
        response = json.load(open_url(url))
        data = response["data"]

        image = data["images"]["original"]
        try:
            if args.max_size == "2MB":
                image = data["images"]["downsized"]
            elif args.max_size == "5MB":
                image = data["images"]["downsized_medium"]
            elif args.max_size == "8MB":
                image = data["images"]["downsized_large"]
        except KeyError:
            pass

        return {
            "id":        data["id"],
            "page_url":  data["url"],
            "rating":    data["rating"],
            "username":  data["username"],  # Can be an empty string
            "image_url": image["url"],
            "width":     int(image["width"]),
            "height":    int(image["height"]),
            "size":      int(image["size"]),
        }
    except urllib.error.URLError as ex:
        if isinstance(ex, urllib.error.HTTPError):
            if ex.code == 404 and args.mode == "id":
                fail("Giphy couldn't find the image; is the ID incorrect?")
            else:
                fail(get_giphy_api_err_msg(ex.code))
        elif isinstance(ex.reason, socket.gaierror) and not test_internet_connection():
            fail("Couldn't contact Giphy's API; is the internet connection down?")
        else:
            fail("Problem using Giphy's API: %s" % str(ex.reason))
    except json.JSONDecodeError as ex:
        fail("Unexpected response from Giphy (JSON error: %s)" % ex.msg)
    except KeyError as ex:
        fail("Unexpected response from Giphy (missing key: %s)" % ex.args[0])


def get_giphy_api_err_msg(response_code):
    """
    Returns an error message for the given HTTP response code from Giphy's API,
    based on this: https://developers.giphy.com/docs/api#response-codes
    """
    if response_code >= 500:
        return "Giphy is experiencing problems right now (code %s)" % response_code

    err_msg = {
        # 404 is handled specially because it can mean something different for id vs translate/random
        400: "Giphy API request was formatted incorrectly or missing a required parameter",
        401: "Giphy API key is missing or invalid",
        403: "Giphy API request wasn't authorized; probably an API key problem",
        414: "Topic was too long, try again with a shorter phrase",
        429: "Too many requests, rate limit exceeded, try again later",
    }.get(response_code)

    if err_msg:
        err_msg += " (code %s)" % response_code
        return err_msg

    return "Giphy API request failed, sorry (code %s)" % response_code


def download_image(image_url):
    """
    Downloads a GIF, returning its raw image data.
    """
    try:
        return open_url(image_url).read()
    except urllib.error.HTTPError as ex:
        fail("Problem downloading GIF (HTTP response code %s)" % ex.code)
    except urllib.error.URLError as ex:
        fail("Problem downloading GIF: %s" % str(ex.reason))


def open_url(url):
    """
    Opens a URL with urllib, and returns the http.client.HTTPResponse object.
    """
    if platform.system() == "Darwin" and platform.release().startswith("20."):
        # Skip SSL cert validation on macOS Big Sur
        # noinspection PyProtectedMember
        context = ssl._create_unverified_context()
        return urllib.request.urlopen(url, context=context)
    else:
        return urllib.request.urlopen(url)


def test_internet_connection():
    """
    Reports whether we're connected to the internet. That's a nuanced concept,
    and this can report a value that's probably "wrong" in various cases,
    but we only use it to customize an error message anyway.
    See https://stackoverflow.com/a/20913928 for more details.
    """
    connected = False  # Pessimism

    # noinspection PyBroadException
    try:
        sock = socket.create_connection(("1.1.1.1", 80), timeout=3)
        connected = True
        sock.close()  # Can raise OSError
    except Exception:
        pass

    return connected


# ----- Displaying images -----

def check_image_capability(args):
    """
    Checks whether the current environment supports displaying images properly.
    A capable terminal is required, and we shouldn't be running in tmux or GNU screen.
    """
    if args.force:
        return None

    # Mintty, Tabby, VS Code, Konsole, and La Terminal (iPhone/iPad) can only show
    # the first frame of an animated GIF, which I *guess* is better than nothing?
    term_program = os.environ.get("TERM_PROGRAM")
    if term_program not in ("iTerm.app", "WezTerm", "mintty", "Tabby", "vscode", "tmux") \
            and not os.environ.get("KONSOLE_VERSION") \
            and os.environ.get("LC_TERMINAL") != "LA_TERMINAL":
        return "This terminal can't display GIFs (probably; pass -f or --force to override)"

    # Both tmux and GNU screen set $TERM to a string beginning with "screen";
    # tmux also sets $TERM_PROGRAM to "tmux", and doesn't set $STY,
    # whereas screen leaves $TERM_PROGRAM as-is, but does set $STY
    starts_with_screen = (os.environ.get("TERM") or "").startswith("screen")
    if term_program == "tmux" or (starts_with_screen and not os.environ.get("STY")):
        return "GIFs can't be displayed in tmux"
    elif starts_with_screen:
        return "GIFs can't be displayed in GNU screen"

    return None  # No problems detected


def display_image(image_b64, image_size, width, image_name):
    """
    Displays a GIF by printing it to the terminal using iTerm's leet escape sequences.
    Call check_image_capability() first.
    """
    # See https://iterm2.com/utilities/imgcat
    open_esc = "\033]"
    close_esc = "\a"

    file_info = "inline=1;size=%s;" % image_size
    if width is not None:
        file_info += "width=%s;" % width
    file_info += "name=%s" % b64encode(image_name.encode("utf-8")).decode("utf-8")

    # if a newline isn't appended (by passing end="" to print()),
    # iTerm and WezTerm both bottom-aligns the text with the bottom of the image
    print("%s1337;File=%s:%s%s" % (open_esc, file_info, image_b64, close_esc))


def display_logo(large):
    """
    Displays a Giphy logo image.
    Call check_image_capability() first.
    """
    # Images from https://support.giphy.com/hc/en-us/articles/360022283772-GIPHY-Brand-Guidelines
    if large:
        # base64 --break=100 -i Poweredby_640px-Black_VertLogo.png | pbcopy
        logo_b64 = """
            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
            """.replace(' ', '')
        logo_size = 9719
        width = "320px"
    else:
        # base64 --break=100 -i Poweredby_100px-Black_VertLogo.png | pbcopy
        logo_b64 = """
            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
            """.replace(' ', '')
        logo_size = 1347
        width = None

    display_image(logo_b64, logo_size, width, "Powered-by-Giphy.png")


# ----- Caching -----

def load_cached_image(image_id):
    """
    Loads a GIF from cache, returning its raw image data, or None if it's not in cache.
    """
    cache_dir, cache_path = get_cache_paths(image_id)

    try:
        with open(cache_path, "rb") as cache_file:
            return cache_file.read()
    except OSError as ex:
        if ex.errno != errno.ENOENT:
            raise  # An error other than file-doesn't-exist occurred; bubble it up

    return None  # The GIF isn't in cache (or the cache directory doesn't even exist)


def cache_image(image_id, image_data):
    """
    Writes a GIF to the cache directory, using its ID to determine its on-disk name.
    Some attempts are made to prevent concurrently-executing instances of this program from stomping on
    each other's use of cache, but concurrent interactions haven't been thoroughly tested.
    """
    cache_dir, cache_path = get_cache_paths(image_id)

    try:
        # Ensure that the cache dir exists
        os.makedirs(cache_dir)
    except OSError:
        if not path.isdir(cache_dir):
            raise

    with tempfile.NamedTemporaryFile(delete=False, dir=cache_dir, suffix=".down") as temp_file:
        temp_path = temp_file.name
        temp_file.write(image_data)
        temp_file.flush()
        fsync(temp_file.fileno())

    try:
        os.replace(temp_path, cache_path)  # Atomic operation
        fsync_dir(cache_dir)
    except OSError:
        # If caching is broken, the program can still work, albeit more slowly,
        # so let's just try to clean up our temp file, then silently continue
        try:
            os.remove(temp_path)
        except OSError:
            pass  # Oh, well


def clean_cache(args):
    """
    Cleans the cache by removing old files, based on last access time,
    until there are at most max_cache files left in the directory.
    If we've somehow messed up in cache_image() and left temp files in the cache directory,
    they are handled here just like GIFs, i.e. as part of the cache which may be aged out.
    """
    cache_dir, _ = get_cache_paths(None)
    if not path.isdir(cache_dir):
        return  # Nothing to do

    cwd = os.getcwd()

    try:
        os.chdir(cache_dir)
        files = sorted(os.listdir(cache_dir), key=path.getatime)
        delete = len(files) - args.max_cache

        for i in range(0, delete):
            try:
                # Attempt to perform atomic delete in a way which won't break with concurrent program runs
                file_name = files[i]
                cache_path = path.join(cache_dir, file_name)
                os.remove(cache_path)
            except OSError as ex:
                if ex.errno != errno.ENOENT:
                    raise  # An error other than file-doesn't-exist occurred; bubble it up
    finally:
        os.chdir(cwd)


def get_cache_paths(image_id):
    """
    Returns paths for the cache directory, and a file inside it for the given GIF.
    We respect $XDG_CACHE_HOME if present, and use per-environment conventions if not.
    https://wiki.archlinux.org/title/XDG_Base_Directory#Specification
    """
    cache_home = os.environ.get("XDG_CACHE_HOME")
    if cache_home is not None and cache_home.startswith("/"):
        return "%s/giphizer" % cache_home

    cache_dir = "~/.cache/giphizer"  # Default
    if platform.system() == "Darwin":
        cache_dir = "~/Library/Caches/Giphizer"
    elif platform.system() == "Windows":
        # Doesn't include Cygwin (like "CYGWIN_NT-10.0-22000") or WSL ("Linux")
        app_data = os.environ.get("LOCALAPPDATA")
        if app_data is not None and app_data != "":
            cache_dir = "%s\\%s" % (app_data, "Giphizer\\cache")

    cache_dir = path.expanduser(cache_dir)
    if image_id is not None:
        return cache_dir, path.join(cache_dir, image_id + ".gif")
    else:
        return cache_dir, None


def fsync(fd):
    """
    More effective fsync on macOS.
    See https://github.com/untitaker/python-atomicwrites for background.
    """
    if platform.system() == "Darwin":
        fcntl.fcntl(fd, fcntl.F_FULLFSYNC)
    else:
        os.fsync(fd)


def fsync_dir(dir_path):
    """
    Ensures that a directory is fsynced, i.e. that any changes to the metadata it contains
    are visible in the file system. No effect on any files in the directory.
    """
    fd = os.open(dir_path, 0)

    try:
        fsync(fd)
    finally:
        os.close(fd)


# ----- Do the things -----

if __name__ == '__main__':
    sys.exit(main())

    # from cProfile import Profile
    # from pstats import SortKey, Stats
    #
    # with Profile() as profile:
    #     print(f"{main() = }")
    #     (
    #         Stats(profile)
    #         .strip_dirs()
    #         .sort_stats(SortKey.CUMULATIVE)
    #         .print_stats()
    #     )
